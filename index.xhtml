<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Control: Robot Control</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Robot Control
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.xhtml');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Robot Control </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> This page describes the system developed.</p>
<div class="image">
<img src="front-view-robot.JPG" alt=""/>
<div class="caption">
photo of the robot from the front</div></div>
    <h1><a class="anchor" id="autotoc_md0"></a>
Functions</h1>
<p >The robot system can be controlled by an operator through a web client.</p>
<div class="image">
<img src="website-rendered.png" alt=""/>
<div class="caption">
screenshot of the website used by the operator</div></div>
    <p >There are two modes of operation. One is a manual mode called "direct control". The other is an automatic mode called "follow wall".</p>
<p >The commands are sent via a HTML form to the webserver hosted by the robot. While a command is executed the controls are disabled. The interaction between web client and webserver is achieved through responding to the form submission and periodic refreshes of the website.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
direct control</h2>
<p >These commands are available:</p>
<ul>
<li>drive forward by 37,7mm</li>
<li>drive backward by 37,7mm</li>
<li>turn left by 86,4°</li>
<li>turn right by 86,4°</li>
</ul>
<p >The numbers are crooked as they are a multiple of the distance of the way which can be measured with the motor encoder.</p>
<p >In direct control mode the trajectory which has been commanded to drive is recorded and displayed as a map. The rendering of the map is not performed by the robot itself. Instead the map data is send as part of the HTML page. The page in turn queries another server capable of PHP to render the map using the provided data. For this a small script is deployed on a server which uses the <a href="https://www.php.net/manual/en/book.image.php">GD library</a>.</p>
<p >If the robot's bumper are pushed (usually because the robot hits an obstacle) the robot stops immediately. Only the drive backward command is effective in this case.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
follow wall</h2>
<p >In follow wall mode the robot follows a wall. For this the distance sensors are used.</p>
<p >The algorithm first instructs the robot to turn around while sweeping its surrounding with the laser-ranging distance sensors. Then it turns towards/outbound the closest distance, adjusts its distance to a fixed value and aligns itself to the wall.</p>
<p >It then repeatedly drives for a small distance while it measures the distance to the wall at the beginning and the end of this distance. With this information it calculates the angle which it needs to turn in order to adjust its distance to the wall to the desired value within a certain distance.</p>
<blockquote class="doxtable">
<p >&zwj;What is the direction to drive to in order to be at distance x after driving for y? </p>
</blockquote>
<p>Then it turns to that direction and repeats the procedure.</p>
<p >In general the algorithm assumes that the wall is straight. It tries to achieve the target distance to the wall. Independent of whether the error is because the robot missed the target or because the wall actually was not straight.</p>
<p >The following sketch has been created with GeoGebra:</p>
<div class="image">
<object type="image/svg+xml" data="WinkelberechnungV4-2.pdf.svg" style="pointer-events: none;"></object>
<div class="caption">
formula to calculate the target vector</div></div>
    <p >The sketch above shows how target vector the the distance to the wall "t" is calculated.</p>
<ol type="1">
<li>The robot starts a position P1 and measures the distance to the wall "c".</li>
<li>The robot drives for a defined distance "d" to the next point P2.</li>
<li>The distance to the wall "f" is measured. f=c+b</li>
<li>Using trigonometric functions the target vector is calculated.</li>
</ol>
<h1><a class="anchor" id="autotoc_md3"></a>
Hardware Setup</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
components</h2>
<div class="image">
<object type="image/svg+xml" data="cmp_system.drawio.svg" style="pointer-events: none;"></object>
<div class="caption">
title</div></div>
    <p >The main components of the system are:</p>
<ul>
<li>Robot System Robby RP5 ROBOT (CCRP5) which contains (among other things):<ul>
<li>chain drive with 2 motors</li>
<li>optical motor encoder made of simple light barriers</li>
</ul>
</li>
<li>NodeMCU version 3</li>
<li>4× distance sensor: Time-of-Flight (ToF), laser-ranging, miniature sensor by STMicroelectronics <a href="https://www.st.com/en/imaging-and-photonics-solutions/vl53l1.html">VL53L1</a></li>
<li>a bumper made of LEGO Mindstorms (first generation) parts with 2 micro-switches</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
robot base CCRP5</h3>
<p >The robot base is the "Robot System Robby RP5 ROBOT (CCRP5)" by Conrad Electronic GmbH. It is a mobile robot with chain drive. Its main processor is a C-Control/BASIC microcomputer. It was originally distributed under the order code <code>19 03 33</code>, EAN: <code>4016138222968</code>.</p>
<p >Resources:</p>
<ul>
<li><a href="https://www.conrad.de/de/p/roboter-robby-rp5-190333.html">product website</a> with firmware, manuals, schematics and more for download</li>
<li><a href="https://rn-wissen.de/wiki/index.php/CCRP5">Wiki article at RN-Wissen.de</a> with detailed description of the circuits</li>
</ul>
<p >As copyright or other restrictions may apply to the resources, I will not distribute them. I can only hope they will remain available.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
NodeMCU</h3>
<p >NodeMCU is a simple board. Its main component is a ESP8266 system on a chip. It contains a Wi-Fi microchip with microcontroller capability. This simplifies to develop programs which can easily connect to the internet.</p>
<p >It can easily be programmed with the Arduino IDE. Board support packages for NodeMCU are available.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
system design</h2>
<p >The CCRP5 has two microcontrollers:</p>
<ul>
<li>subsystem IC2 <code>MC68HC705KJ1</code></li>
<li>main controller IC7 <code>MC68HC05B6</code></li>
</ul>
<p >The CCRP5 is designed such as, the subsystem is only programmed by the manufacturer. There is no in-system programming interface. All applications shall be written for the main controller.</p>
<p >The main controller should be programmed with a proprietary development environment CCEW32D. Programs must be written in CCBASIC, which is a dialect of the BASIC programming language. The applications are based on a firmware <code>P5DRIV.S19</code>. CCBASIC is a low level language. The documentation is available to a limited extent.</p>
<p >This projects aims to control the hardware of the CCRP5 without the CCRP5 microcontrollers. Thus an additional "piggyback" PCBA is installed onto the basis CCRP5 PCBA which is tapping into the signals from the CCRP5. The piggyback PCBA includes the NodeMCU board.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
connections</h2>
<h3><a class="anchor" id="autotoc_md9"></a>
Piggyback PCBA</h3>
<p >The schematics of the piggyback PCBA are described in <code>hardware/robot-control-circuit/robot-control-circuit.sch</code>.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Basis PCBA</h3>
<p >The original schematics can be retrieved at the above mentioned resources.</p>
<p >Some modifications were made to the CCRP5's PCBA. The signals <code>D/A 1</code> and <code>D/A 2</code> have been disconnected from the pins of the CCRP5's main microcontroller (IC7) because the pins are configured as drain (referencing to CCRP5's schematics). This interferes with the control of the NodeMCU and causes an 80mA current. The signals have been disconnected by un-soldering and lifting of the microcontroller's pins.</p>
<p >Also the IO-expander <code>I11</code> has been disconnected in order to be able to control the current for the IR-LEDs <code>D3</code> and <code>D4</code>.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Software</h1>
<p >The source code is written in C++. It is compiled and programmed with the <a href="https://www.arduino.cc/en/Main/Software">Arduino IDE</a>.</p>
<p >Dependencies:</p>
<ul>
<li><a href="https://www.arduino.cc/en/Main/Software">Arduino IDE</a>. Tested with v2.0.0-beta.4 should work with 1.5.x+.</li>
<li>The <a href="https://github.com/esp8266/Arduino">board support package for the ESP8266 chip</a> must be installed. Tested using version 2.7.4. Version 3.0.0, (3.0.1 not tested) and 3.0.2 do not work because of <a href="https://github.com/espressif/esp-idf/issues/4542">this bug</a>.</li>
<li>The <a href="https://github.com/stm32duino/VL53L1">Arduino library VL53L1 by STM32duino</a> must be installed. Tested using version 2.0.1.</li>
<li>The <a href="https://github.com/wizard97/SimplyAtomic">SimplyAtomic library</a> must be installed. Tested in version 1.0.</li>
<li>The <a href="https://github.com/blemasle/arduino-mcp23017">MPC23017 library by Bertrand Lemasle</a> must be installed. Tested in version 2.0.0.</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Developing without Arduino IDE</h2>
<p >In case one wants to use an IDE other than Arduino to write the code some provisions should be met:</p>
<ul>
<li>Add the following include paths (where <code>${ARDUINO_LIB_PATH}</code> is the path to the Arduino libraries (for example <code>~/Arduino/libraries</code>), <code>${AVR_PATH}</code> is the path to the AVR header files (for example <code>~/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include</code>), <code>${ESP8266_HARDWARE_PATH}</code> is the path to the hardware part of the ESP8266 board support package (for example <code>~/.arduino15/packages/esp8266/hardware/esp8266/2.7.4</code>), <code>${ESP8266_COMPILER_PATH}</code> is the path to the software part of the ESP8266 board support package (for example <code>~/.arduino15/packages/esp8266/tools/xtensa-lx106-elf-gcc/2.5.0-4-b40a506</code>)):<ul>
<li><code>${AVR_PATH}</code></li>
<li><code>${ARDUINO_LIB_PATH}/MCP23017/src</code></li>
<li><code>${ARDUINO_LIB_PATH}/SimplyAtomic</code></li>
<li><code>${ARDUINO_LIB_PATH}/STM32duino_VL53L1/src</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/cores/esp8266</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/tools/sdk/include</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/tools/sdk/lwip2/include</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/variants/nodemcu</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/libraries/Wire</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/libraries/ESP8266WiFi/src</code></li>
<li><code>${ESP8266_HARDWARE_PATH}/libraries/ESP8266WebServer/src</code></li>
<li><code>${ESP8266_COMPILER_PATH}/lib/gcc/xtensa-lx106-elf/4.8.2/include</code></li>
<li><code>${ESP8266_COMPILER_PATH}/xtensa-lx106-elf/include</code></li>
<li><code>${ESP8266_COMPILER_PATH}/xtensa-lx106-elf/include/c++/4.8.2</code></li>
</ul>
</li>
<li>Add the following preprocessor macros:<ul>
<li><code>ARDUINO_ARCH_ESP8266</code></li>
</ul>
</li>
</ul>
<p >For compiling and flashing the Arduino IDE is recommended.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Configuration</h2>
<p >In order to reduce dynamic memory usage, one may reduce the maximum number of range data produced by the VL53L1 library. In order to achive that, add the following line to the <a href="https://arduino.github.io/arduino-cli/0.20/platform-specification/#platformlocaltxt"><code>platform.local.txt</code></a> file. That file must be in <code>${ESP8266_HARDWARE_PATH}</code>. Create it if not existent. </p><pre class="fragment">compiler.cpp.extra_flags=-DVL53L1_MAX_RANGE_RESULTS=1
</pre><p> This defines a predefined macro which sets the number of maximum range data to 1.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Issues</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Distance measurement depends on orientation</h2>
<p >A major issue with the system design is, that the shortest distance measured to another object depends considerably on the orientation of the robot to that object. This is due to the fact that the distance is measured at fixed directions with a tight beam. The robot measures the distance at some angles. The measurement is done with a tight beam and does not take into account variations within a circular sector.</p>
<p >The result is, that in order to determine the shortest distance to an object, the robot must rotate such that a full sweep around the robot is performed.</p>
<p >This also has the following effect. If the robot tries to align to a straight wall, it will turn in order to adjust its distance to the wall. Turning will result in a changed perceived distance to the straight wall.</p>
<p >For example in case the robot is aligned to the wall but the distance is too short. The robot will turn away from the wall in order to increase its actual distance to the wall. By turning away (pure rotation) from the wall the sensor which was previously directed to the wall (parallel to the normal vector) will now light the wall with a non-right angle. Thus the measured distance by that sensor will increase. Even though the actual distance did not really increase.</p>
<p >This effect could be counted back only if the shape of the object is known (for example a straight wall). But usually the shape of the object is unknown.</p>
<p >This effects complicates the task to follow the shape of objects. Especially using a simple PID controller.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Coarse odometry sensor</h2>
<p >Movements of the robot (driving, turning, rotation) are performed in increments which are captured by an optical light barrier. That light barrier is triggered when a cog in the transmission of the drives is at certain angles. Using the information of the direction in which a motor turns, this information is used to calculate the movement of the robot.</p>
<p >Conversely movements of the robot must be in full increments of the slots in the cog. As the transmission of that cog to the ground is not very high, or the slots are too distant, the minimum distance driven by one chain drive in one increment (distance between slots) is approximately 38mm.</p>
<p >Movements by multiples of such big increments makes the control of the robot position difficult. Especially as the robot can not adjust its orientation by small angles. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 25 2022 10:42:09 for Robot Control by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
